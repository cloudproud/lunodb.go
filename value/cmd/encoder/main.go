package main

import (
	"fmt"
	"os"
	"strings"
	"text/template"
)

type definition struct {
	Encoder     string
	Type        string
	Package     string
	NotNullable bool
}

var types = []definition{
	{Encoder: "String", Type: "string"},
	{Encoder: "Bool", Type: "bool"},
	{Encoder: "Int8", Type: "int8"},
	{Encoder: "Int16", Type: "int16"},
	{Encoder: "Int32", Type: "int32"},
	{Encoder: "Int64", Type: "int64"},
	{Encoder: "Int64", Type: "int"},
	{Encoder: "Uint8", Type: "uint8"},
	{Encoder: "Uint16", Type: "uint16"},
	{Encoder: "Uint32", Type: "uint32"},
	{Encoder: "Uint64", Type: "uint64"},
	{Encoder: "Float32", Type: "float32"},
	{Encoder: "Float64", Type: "float64"},
	// {Encoder: "Time", Type: "Time", Package: "time"},
	// {Encoder: "Duration", Type: "Duration", Package: "duration"},
	{Encoder: "Inet", Type: "Prefix", Package: "net/netip"},
	{Encoder: "UUID", Type: "[16]byte", NotNullable: true},
	// {Encoder: "Byte", Type: "[]byte", NotNullable: true},
	{Encoder: "Object", Type: "map[string]any", NotNullable: true},
}

var tmpl = `// Code generated by go generate; DO NOT EDIT.
package value

import (
	"fmt"
	{{ range $pkg, $alias := .Packages }}
	{{ $alias }} "{{ $pkg }}"
	{{- end }}

	"github.com/cloudproud/lunodb.go/types"
	lunopb "github.com/cloudproud/lunodb.api/proto/types"
)

func Encode(val any, buf []byte) (_ *lunopb.Type, _ []byte, err error) {
	switch v := val.(type) {
	{{- range .Types }}
	case {{.Type}}:
		buf, err = Encode{{.Encoder}}(v, buf)
		return types.Basic{{.Encoder}}, buf, err
	{{- end }}
	{{- range .Types }}
	{{- if not .NotNullable }}
	case *{{.Type}}:
		buf, err = Encode{{.Encoder}}(v, buf)
		return types.Basic{{.Encoder}}, buf, err
	{{- end }}
	{{- end }}
	{{- range .Types }}
	case []{{.Type}}:
		buf, err = EncodeArray(v, buf)
		return types.NewArray(types.Basic{{.Encoder}}), buf, err
	{{- end }}
	{{- range .Types }}
	{{- if not .NotNullable }}
	case []*{{.Type}}:
		buf, err = EncodeArray(v, buf)
		return types.NewArray(types.Basic{{.Encoder}}), buf, err
	{{- end }}
	{{- end }}
	}

	return types.BasicAny, buf, fmt.Errorf("unsupported type: %T", val)
}
`

type TemplateData struct {
	Types    []definition
	Packages map[string]string
}

func main() {
	if err := run(); err != nil {
		os.Stderr.WriteString(err.Error() + "\n")
		os.Exit(1)
	}
}

func run() error {
	t := template.Must(template.New("switch").Parse(tmpl))

	f, err := os.Create("encoder.go")
	if err != nil {
		return err
	}
	defer f.Close()

	packages := make(map[string]string)
	for index, typ := range types {
		if typ.Package == "" {
			continue
		}

		parts := strings.Split(typ.Package, "/")
		packages[typ.Package] = parts[len(parts)-1]
		types[index].Type = fmt.Sprintf("%s.%s", packages[typ.Package], typ.Type)
	}

	return t.Execute(f, TemplateData{
		Types:    types,
		Packages: packages,
	})
}
